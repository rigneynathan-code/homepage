<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360 Breakout - Left Side POW</title>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: radial-gradient(circle at center, #4a148c, #1a0033);
            font-family: 'Bangers', cursive;
            color: #ffeb3b;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
        }
        canvas {
            background-color: rgba(20, 20, 30, 0.9);
            border-radius: 50%;
            box-shadow: 10px 10px 0px rgba(0,0,0,0.5); 
            border: 4px solid #000;
            cursor: none; 
            max-width: 90vh;
            max-height: 90vh;
        }
        
        #top-ui {
            position: absolute;
            top: 20px;
            text-align: center;
            text-shadow: 3px 3px 0px #000;
            z-index: 10;
            width: 100%;
            pointer-events: none; 
        }
        #bottom-ui {
            position: absolute;
            bottom: 20px;
            text-align: center;
            text-shadow: 2px 2px 0px #000;
            z-index: 10;
            width: 100%;
            pointer-events: none;
        }
        
        /* RIGHT SIDE CONTROLS */
        #right-ui {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 20;
        }

        /* LEFT SIDE UI */
        #left-ui {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 20;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border: 2px solid #00e5ff;
            border-radius: 10px;
            text-align: center;
            box-shadow: 5px 5px 0px rgba(0,0,0,0.5);
            width: 100px;
        }

        .control-label {
            color: #00e5ff;
            font-size: 1.2rem;
            margin-bottom: 5px;
            text-shadow: 1px 1px 0 #000;
        }

        .value-display {
            font-size: 2rem;
            color: white;
            margin: 5px 0;
            text-shadow: 2px 2px 0 #000;
        }

        .btn-row {
            display: flex;
            justify-content: space-between;
        }

        .adjust-btn {
            background-color: #ffeb3b;
            border: 2px solid #000;
            color: #000;
            font-family: 'Bangers', cursive;
            font-size: 1.2rem;
            width: 40px;
            height: 30px;
            cursor: pointer;
            border-radius: 5px;
            transition: transform 0.1s;
        }
        .adjust-btn:hover { transform: scale(1.1); background-color: #fff; }
        .adjust-btn:active { transform: scale(0.95); }

        .restart-btn {
            background-color: #ff3333; 
            color: white; 
            width: 100%; 
            margin-top: 10px;
        }
        .restart-btn:hover { background-color: #ff6666; }

        .cheater-btn {
            background-color: #555; 
            color: white; 
            width: 100%; 
            margin-top: 5px;
        }
        
        h2 { margin: 0; font-size: 1.5rem; color: #00e5ff; }
        h3 { margin: 5px 0; font-size: 2.5rem; }
        p { margin: 5px 0; font-size: 1.2rem; letter-spacing: 1px; }
        
        #push-status {
            font-size: 1.5em;
            color: #00e5ff;
        }
        .instruction {
            color: #ccc;
            font-family: sans-serif;
            font-size: 0.9em;
            margin-top: 5px;
            text-shadow: 1px 1px 0 #000;
        }
        
        /* VERTICAL TIMER */
        #timer-group {
            height: 35vh; 
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
        }
        #timer-container {
            width: 20px; 
            flex-grow: 1; 
            background: #333;
            border: 2px solid #000;
            margin-top: 5px;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
        }
        #timer-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(to top, #ffeb3b, #ff9800);
            transform-origin: bottom;
            position: absolute;
            bottom: 0;
        }

        #lives-display {
            color: #ff3333;
            font-size: 1.5rem;
            margin-top: 5px;
        }
        
        #overlay-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            color: #fff;
            text-shadow: 4px 4px 0 #000;
            text-align: center;
            z-index: 30;
            pointer-events: none;
            display: block; 
        }
        .sub-msg {
            font-size: 1.5rem;
            color: #00e5ff;
            margin-top: 10px;
        }

        /* COMIC POW EFFECT - UPDATED POSITION */
        #pow-effect {
            position: absolute;
            top: 50%;
            /* Moved to Left side, centered over the timer roughly */
            left: 160px; 
            transform: translate(-50%, -50%) scale(0) rotate(-15deg);
            width: 250px;
            height: 200px;
            background: #ffeb3b;
            color: #ff0000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3.5rem;
            font-weight: bold;
            z-index: 40;
            pointer-events: none;
            opacity: 0;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s;
            clip-path: polygon(
                20% 0%, 30% 10%, 45% 0%, 50% 15%, 65% 5%, 80% 20%, 
                100% 10%, 90% 40%, 100% 60%, 85% 70%, 95% 90%, 
                70% 85%, 60% 100%, 45% 85%, 25% 100%, 30% 80%, 
                0% 90%, 15% 65%, 0% 45%, 15% 25%
            );
            filter: drop-shadow(5px 5px 0px #000);
            text-shadow: 3px 3px 0 #000;
            text-align: center;
            line-height: 1;
        }
        #pow-effect.active {
            /* Keep rotation when scaling up */
            transform: translate(-50%, -50%) scale(1.2) rotate(-10deg);
            opacity: 1;
        }
    </style>
</head>
<body>

    <div id="top-ui">
        <h2>Space to Pause/Start</h2>
        <h3 id="status">STATUS: MENU</h3>
        <p id="score">SCORE: 0</p>
        <p id="lives-display">LIVES: 5</p>
    </div>

    <canvas id="gameCanvas" width="800" height="800"></canvas>
    
    <div id="overlay-msg">
        360 BREAKOUT
        <div class="sub-msg">PRESS SPACE TO START</div>
    </div>

    <div id="pow-effect">NEW WAVE!</div>

    <div id="left-ui">
        <div class="control-group" id="timer-group">
            <div class="control-label">WAVE</div>
            <div id="timer-container"><div id="timer-bar"></div></div>
        </div>
    </div>

    <div id="bottom-ui">
        <div id="push-status">MAGNET: READY</div>
        <p class="instruction">UP: Quick Shot | DOWN: Precision Aim</p>
    </div>

    <div id="right-ui">
        <div class="control-group">
            <div class="control-label">PADDLE</div>
            <div class="btn-row">
                <button class="adjust-btn" onclick="adjustPaddle(1)">▲</button>
                <button class="adjust-btn" onclick="adjustPaddle(-1)">▼</button>
            </div>
            <div id="paddle-val" class="value-display">30</div>
        </div>
        <div class="control-group">
            <div class="control-label">BALL</div>
            <div class="btn-row">
                <button class="adjust-btn" onclick="adjustBall(1)">▲</button>
                <button class="adjust-btn" onclick="adjustBall(-1)">▼</button>
            </div>
            <div id="ball-val" class="value-display">1.8</div>
        </div>
        <div class="control-group">
            <button class="adjust-btn restart-btn" onclick="fullRestart()">RESTART</button>
        </div>
        <div class="control-group">
            <div class="control-label">CHEATER</div>
            <button id="cheater-btn" class="adjust-btn cheater-btn" onclick="toggleCheater()">OFF</button>
        </div>
    </div>

<script>
    // --- Configuration ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives-display');
    const pushStatusEl = document.getElementById('push-status');
    const timerBarEl = document.getElementById('timer-bar');
    const paddleValEl = document.getElementById('paddle-val');
    const ballValEl = document.getElementById('ball-val');
    const overlayEl = document.getElementById('overlay-msg');
    const cheaterBtn = document.getElementById('cheater-btn');
    const powEl = document.getElementById('pow-effect');

    const CENTER_X = canvas.width / 2;
    const CENTER_Y = canvas.height / 2;
    const RADIUS = 360; 
    const BALL_RADIUS = 7; 
    const PROJECTILE_RADIUS = 5; 
    
    let normalSpeed = 1.8; 
    let paddleSpeed = 0.03; 
    
    const SUPER_SPEED = 4.8; 
    const PADDLE_WIDTH_RADIANS = 0.7; 

    const COOLDOWN_FIXED_MS = 2000; 
    const PUSH_MAX_DISTANCE = 80; 

    const TARGET_BRICK_COUNT = 20;
    const SPAWN_INTERVAL_MS = 10000; 
    const TARGET_BOMB_COUNT = 4;

    const BRICK_W = 30;
    const BRICK_H = 15;
    const BRICK_SPAWN_RADIUS = 140; 
    const MULTIBALL_CHANCE = 0.15; 
    const SPEED_BRICK_CHANCE = 0.10; 

    const SCORE_NORMAL = 100;
    const SCORE_SHRAPNEL = 200;
    const SCORE_BOMB_PENALTY = 500;

    // --- State Variables ---
    let gameState = 'MENU'; 
    let paddleAngle = Math.PI / 2; 
    let entities = []; 
    let projectiles = []; 
    let particles = [];
    
    let score = 0;
    let lives = 5; 
    let cheaterMode = false; 
    
    let lastSpawnTime = 0;
    let lastPushTime = -COOLDOWN_FIXED_MS; 
    
    let heroBrickKillCount = 0;
    let isHoldingBall = false;
    let isSuperCharged = false; 

    let isAimingMode = false;
    let aimOffsetAngle = 0; 

    let ball = {
        x: CENTER_X,
        y: CENTER_Y + 180, 
        dx: 0, 
        dy: 0  
    };

    // --- AUDIO SYSTEM ---
    let audioCtx;
    function initAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }
    
    function playSound(type) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        const now = audioCtx.currentTime;

        if (type === 'paddle') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(600, now); osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
            gainNode.gain.setValueAtTime(0.1, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'brick') {
            osc.type = 'square'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            gainNode.gain.setValueAtTime(0.05, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'gold' || type === 'speed') {
            osc.type = 'triangle'; osc.frequency.setValueAtTime(600, now); osc.frequency.linearRampToValueAtTime(1200, now + 0.1);
            gainNode.gain.setValueAtTime(0.1, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            osc.start(now); osc.stop(now + 0.3);
        } else if (type === 'shoot') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
            gainNode.gain.setValueAtTime(0.1, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            osc.start(now); osc.stop(now + 0.3);
        } else if (type === 'bomb') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(10, now + 0.4);
            gainNode.gain.setValueAtTime(0.2, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
            osc.start(now); osc.stop(now + 0.4);
        } else if (type === 'gameover') {
            osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); osc.frequency.linearRampToValueAtTime(50, now + 1.0);
            gainNode.gain.setValueAtTime(0.2, now); gainNode.gain.linearRampToValueAtTime(0.01, now + 1.0);
            osc.start(now); osc.stop(now + 1.0);
        }
    }

    // --- PARTICLE SYSTEM ---
    function createExplosion(x, y, color) {
        for (let i = 0; i < 15; i++) {
            particles.push({
                x: x, y: y, dx: (Math.random() - 0.5) * 6, dy: (Math.random() - 0.5) * 6,
                size: Math.random() * 4 + 2, color: color, life: 1.0 
            });
        }
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i]; p.x += p.dx; p.y += p.dy; p.life -= 0.02; p.size *= 0.95; 
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function drawParticles() {
        for (let p of particles) {
            ctx.fillStyle = p.color; ctx.globalAlpha = p.life;
            ctx.fillRect(p.x, p.y, p.size, p.size); ctx.globalAlpha = 1.0;
        }
    }

    // --- Control Logic ---
    function adjustPaddle(dir) {
        paddleSpeed += (dir * 0.005);
        if (paddleSpeed < 0.005) paddleSpeed = 0.005;
        if (paddleSpeed > 0.1) paddleSpeed = 0.1;
        paddleValEl.innerText = Math.round(paddleSpeed * 1000);
    }

    function adjustBall(dir) {
        normalSpeed += (dir * 0.1);
        if (normalSpeed < 0.5) normalSpeed = 0.5;
        if (normalSpeed > 10.0) normalSpeed = 10.0;
        ballValEl.innerText = normalSpeed.toFixed(1);
        if (gameState === 'PLAYING' && !isHoldingBall && !isSuperCharged) {
            const currentMag = Math.sqrt(ball.dx*ball.dx + ball.dy*ball.dy);
            if (currentMag > 0) {
                ball.dx = (ball.dx / currentMag) * normalSpeed;
                ball.dy = (ball.dy / currentMag) * normalSpeed;
            }
        }
    }
    
    function fullRestart() {
        if (document.activeElement instanceof HTMLElement) document.activeElement.blur();
        startMatch();
        gameState = 'PLAYING';
    }

    function toggleCheater() {
        if (document.activeElement instanceof HTMLElement) document.activeElement.blur();
        cheaterMode = !cheaterMode;
        if (cheaterMode) {
            cheaterBtn.innerText = "ON";
            cheaterBtn.style.backgroundColor = "#39ff14"; 
            cheaterBtn.style.color = "#000";
            livesEl.innerText = "LIVES: ∞";
        } else {
            cheaterBtn.innerText = "OFF";
            cheaterBtn.style.backgroundColor = "#555";
            cheaterBtn.style.color = "#fff";
            livesEl.innerText = `LIVES: ${lives}`;
        }
    }

    // --- VISUAL FX ---
    function triggerPow() {
        powEl.classList.add('active');
        setTimeout(() => {
            powEl.classList.remove('active');
        }, 1000);
    }

    // Input Handling
    let leftPressed = false;
    let rightPressed = false;
    let upPressed = false; 
    let downPressed = false; 

    window.addEventListener('keydown', (e) => {
        if(e.key === 'ArrowLeft') leftPressed = true;
        if(e.key === 'ArrowRight') rightPressed = true;
        if(e.key === 'ArrowUp') upPressed = true; 
        if(e.key === 'ArrowDown') downPressed = true; 
        
        if(e.code === 'Space') {
            e.preventDefault(); 
            if (gameState === 'MENU' || gameState === 'GAMEOVER') startMatch();
            else if (gameState === 'PLAYING') { gameState = 'PAUSED'; statusEl.innerText = "STATUS: PAUSED"; }
            else if (gameState === 'PAUSED') { gameState = 'PLAYING'; statusEl.innerText = "STATUS: PLAYING"; }
        }
    });

    window.addEventListener('keyup', (e) => {
        if(e.key === 'ArrowLeft') leftPressed = false;
        if(e.key === 'ArrowRight') rightPressed = false;
        if(e.key === 'ArrowUp') upPressed = false; 
        if(e.key === 'ArrowDown') downPressed = false; 
    });

    function spawnEntity(type, count) {
        let spawned = 0; let attempts = 0;
        while (spawned < count && attempts < 2000) {
            attempts++;
            const rX = (Math.random() * (BRICK_SPAWN_RADIUS * 2)) - BRICK_SPAWN_RADIUS;
            const rY = (Math.random() * (BRICK_SPAWN_RADIUS * 2)) - BRICK_SPAWN_RADIUS;
            const finalX = CENTER_X + rX; const finalY = CENTER_Y + rY;
            const dist = Math.sqrt(rX*rX + rY*rY);
            if (dist > BRICK_SPAWN_RADIUS) continue;

            let overlaps = false;
            for (let b of entities) {
                if (finalX < b.x + b.w + 5 && finalX + BRICK_W > b.x - 5 && finalY < b.y + b.h + 5 && finalY + BRICK_H > b.y - 5) {
                    overlaps = true; break;
                }
            }

            if (!overlaps) {
                let finalType = type; let finalColor = '#ff0000'; 
                if (type === 'brick') {
                    let rand = Math.random();
                    if (rand < MULTIBALL_CHANCE) { finalType = 'multiball'; finalColor = '#ffd700'; } 
                    else if (rand < MULTIBALL_CHANCE + SPEED_BRICK_CHANCE) { finalType = 'speed'; finalColor = '#00e5ff'; } 
                    else { const hue = Math.floor(Math.random() * 360); finalColor = `hsl(${hue}, 100%, 50%)`; }
                }
                entities.push({ x: finalX, y: finalY, w: BRICK_W, h: BRICK_H, active: true, type: finalType, color: finalColor });
                spawned++;
            }
        }
    }

    function ensureBrickCount() {
        let brickCount = entities.filter(e => e.active && e.type !== 'bomb').length;
        let needed = TARGET_BRICK_COUNT - brickCount;
        if (needed > 0) spawnEntity('brick', needed);
        let bombCount = entities.filter(e => e.active && e.type === 'bomb').length;
        if (bombCount < TARGET_BOMB_COUNT) spawnEntity('bomb', TARGET_BOMB_COUNT - bombCount);
    }

    function initGame() {
        gameState = 'MENU';
        overlayEl.style.display = 'block';
        overlayEl.innerHTML = `360 BREAKOUT<div class="sub-msg">PRESS SPACE TO START</div>`;
        statusEl.innerText = "STATUS: MENU"; statusEl.style.color = "#fff";
        score = 0; entities = []; ensureBrickCount(); lives = 5; 
        
        if (cheaterMode) livesEl.innerText = "LIVES: ∞";
        else livesEl.innerText = `LIVES: ${lives}`;
        
        ball.x = CENTER_X; ball.y = CENTER_Y + 180; ball.dx = 0; ball.dy = 0;
    }

    function startMatch() {
        initAudio();
        gameState = 'PLAYING';
        overlayEl.style.display = 'none';
        score = 0; scoreEl.innerText = "SCORE: 0";
        lives = 5; heroBrickKillCount = 0;
        lastPushTime = -COOLDOWN_FIXED_MS; lastSpawnTime = Date.now(); 
        entities = []; ensureBrickCount(); respawnBall();
        statusEl.innerText = "STATUS: PLAYING"; statusEl.style.color = "#ffeb3b"; 
        
        if (cheaterMode) livesEl.innerText = "LIVES: ∞";
        else livesEl.innerText = `LIVES: ${lives}`;
    }

    function respawnBall() {
        projectiles = []; isHoldingBall = false; isSuperCharged = false; aimOffsetAngle = 0;
        ball.x = CENTER_X; ball.y = CENTER_Y + 180; 
        lastPushTime = Date.now() - COOLDOWN_FIXED_MS; 
        const angle = Math.random() * Math.PI + Math.PI; 
        ball.dx = Math.cos(angle) * normalSpeed; ball.dy = Math.sin(angle) * normalSpeed;
        paddleAngle = Math.PI / 2; 
    }
    
    function getRayIntersection(rayOrigin, rayDir, rect) {
        let tNearX = (rect.x - rayOrigin.x) / rayDir.x; let tFarX = (rect.x + rect.w - rayOrigin.x) / rayDir.x;
        if (tNearX > tFarX) [tNearX, tFarX] = [tFarX, tNearX];
        let tNearY = (rect.y - rayOrigin.y) / rayDir.y; let tFarY = (rect.y + rect.h - rayOrigin.y) / rayDir.y;
        if (tNearY > tFarY) [tNearY, tFarY] = [tFarY, tNearY];
        if (tNearX > tFarY || tNearY > tFarX) return null; 
        let tHit = Math.max(tNearX, tNearY); let tFar = Math.min(tFarX, tFarY);
        if (tFar < 0) return null; if (tHit < 0) tHit = tFar; 
        let normal = { x: 0, y: 0 };
        if (tNearX > tNearY) normal.x = -Math.sign(rayDir.x); else normal.y = -Math.sign(rayDir.y);
        return { t: tHit, x: rayOrigin.x + rayDir.x * tHit, y: rayOrigin.y + rayDir.y * tHit, normal: normal };
    }

    function update() {
        if (gameState !== 'PLAYING') return;
        updateParticles();
        const now = Date.now();

        // Wave Logic
        const timeSinceSpawn = now - lastSpawnTime;
        if (timeSinceSpawn >= SPAWN_INTERVAL_MS) {
            ensureBrickCount(); lastSpawnTime = now; 
            playSound('gold'); 
            triggerPow(); 
        }
        const percent = 1 - (timeSinceSpawn / SPAWN_INTERVAL_MS);
        timerBarEl.style.transform = `scaleY(${percent})`;

        const timeSincePush = now - lastPushTime;
        const cooldownReady = timeSincePush >= COOLDOWN_FIXED_MS;

        if (cooldownReady) {
            pushStatusEl.innerText = "MAGNET: READY!"; pushStatusEl.style.color = "#00e5ff"; 
        } else {
            const timeLeft = ((COOLDOWN_FIXED_MS - timeSincePush) / 1000).toFixed(1);
            pushStatusEl.innerText = `RECHARGING: ${timeLeft}s`; pushStatusEl.style.color = "#888"; 
        }

        // --- PADDLE & AIMING INPUT ---
        const isPrecisionMode = isHoldingBall && (downPressed || Math.abs(aimOffsetAngle) > 0.01);

        if (isPrecisionMode) {
            if (downPressed) {
                if (leftPressed) aimOffsetAngle -= 0.02;
                if (rightPressed) aimOffsetAngle += 0.02;
                if (aimOffsetAngle < -1.2) aimOffsetAngle = -1.2;
                if (aimOffsetAngle > 1.2) aimOffsetAngle = 1.2;
            }
        } 
        else {
            if (leftPressed) paddleAngle -= paddleSpeed;
            if (rightPressed) paddleAngle += paddleSpeed;
            if (!isHoldingBall) aimOffsetAngle = 0;
        }
        
        if (paddleAngle < 0) paddleAngle += Math.PI * 2;
        if (paddleAngle > Math.PI * 2) paddleAngle -= Math.PI * 2;

        const holdDist = RADIUS - BALL_RADIUS - 15;
        const holdX = CENTER_X + Math.cos(paddleAngle) * holdDist;
        const holdY = CENTER_Y + Math.sin(paddleAngle) * holdDist;

        if (!isHoldingBall && (upPressed || downPressed) && cooldownReady) {
            const distBallToPaddle = Math.sqrt((ball.x - holdX)**2 + (ball.y - holdY)**2);
            if (distBallToPaddle < PUSH_MAX_DISTANCE) {
                isHoldingBall = true;
                isSuperCharged = false; 
                aimOffsetAngle = 0;
            }
        }

        if (isHoldingBall) {
            ball.x = holdX;
            ball.y = holdY;
            ball.dx = 0;
            ball.dy = 0;

            if (isAimingMode) {
                // waiting
            } else if (downPressed === false && Math.abs(aimOffsetAngle) > 0.01) {
                isHoldingBall = false;
                lastPushTime = Date.now();
                isSuperCharged = true;
                playSound('shoot');
                
                const shootAngle = paddleAngle + Math.PI + aimOffsetAngle;
                ball.dx = Math.cos(shootAngle) * SUPER_SPEED;
                ball.dy = Math.sin(shootAngle) * SUPER_SPEED;
                aimOffsetAngle = 0;
            } else if (!upPressed && !downPressed && Math.abs(aimOffsetAngle) <= 0.01) {
                isHoldingBall = false;
                lastPushTime = Date.now();
                isSuperCharged = true;
                playSound('shoot');
                const shootAngle = paddleAngle + Math.PI;
                ball.dx = Math.cos(shootAngle) * SUPER_SPEED;
                ball.dy = Math.sin(shootAngle) * SUPER_SPEED;
            }
        } else {
            ball.x += ball.dx;
            ball.y += ball.dy;
        }

        // --- PROJECTILES ---
        for (let i = projectiles.length - 1; i >= 0; i--) {
            let p = projectiles[i];
            p.x += p.dx;
            p.y += p.dy;

            for (let b of entities) {
                if (!b.active) continue;
                if (p.x > b.x && p.x < b.x + b.w && p.y > b.y && p.y < b.y + b.h) {
                    if (b.type === 'bomb') {
                        let centerX = b.x + b.w/2; let centerY = b.y + b.h/2;
                        if (Math.abs(p.x - centerX) > Math.abs(p.y - centerY)) p.dx = -p.dx; else p.dy = -p.dy;
                    } else {
                        b.active = false;
                        score += SCORE_SHRAPNEL; scoreEl.innerText = `SCORE: ${score}`;
                        createExplosion(b.x + BRICK_W/2, b.y + BRICK_H/2, b.color);
                        playSound(b.type === 'multiball' ? 'gold' : 'brick');
                        let centerX = b.x + b.w/2; let centerY = b.y + b.h/2;
                        if (Math.abs(p.x - centerX) > Math.abs(p.y - centerY)) p.dx = -p.dx; else p.dy = -p.dy;
                    }
                    break; 
                }
            }
            const distP = Math.sqrt((p.x - CENTER_X)**2 + (p.y - CENTER_Y)**2);
            if (distP > RADIUS) projectiles.splice(i, 1);
        }

        // --- MAIN BALL COLLISION ---
        for (let b of entities) {
            if (!b.active) continue;
            let testX = ball.x; let testY = ball.y;
            if (ball.x < b.x) testX = b.x; else if (ball.x > b.x + b.w) testX = b.x + b.w;
            if (ball.y < b.y) testY = b.y; else if (ball.y > b.y + b.h) testY = b.y + b.h;
            let distX = ball.x - testX; let distY = ball.y - testY;
            let distance = Math.sqrt((distX*distX) + (distY*distY));

            if (distance <= BALL_RADIUS) {
                if (b.type === 'bomb') {
                    if (cheaterMode) {
                        score = 1; // PUNISHMENT
                    } else {
                        lives--; livesEl.innerText = `LIVES: ${lives}`;
                        score = Math.max(0, score - SCORE_BOMB_PENALTY);
                    }
                    scoreEl.innerText = `SCORE: ${score}`;
                    
                    playSound('bomb'); createExplosion(b.x + BRICK_W/2, b.y + BRICK_H/2, '#ff0000');
                    b.active = false; 

                    if (lives <= 0 && !cheaterMode) {
                        playSound('gameover'); gameState = 'GAMEOVER'; statusEl.innerText = "STATUS: GAME OVER";
                        statusEl.style.color = "#ff3333"; overlayEl.innerHTML = `GAME OVER<div class="sub-msg">PRESS SPACE TO RESTART</div>`;
                        overlayEl.style.display = 'block';
                    } else { respawnBall(); }
                    return; 
                }
                
                b.active = false; 
                score += SCORE_NORMAL; scoreEl.innerText = `SCORE: ${score}`;
                createExplosion(b.x + BRICK_W/2, b.y + BRICK_H/2, b.color);
                playSound(b.type === 'multiball' || b.type === 'speed' ? 'gold' : 'brick');

                heroBrickKillCount++;
                if (heroBrickKillCount % 3 === 0) {
                    let candidates = entities.filter(e => e.active && e.type === 'brick');
                    if (candidates.length > 0) {
                        let lucky = candidates[Math.floor(Math.random() * candidates.length)];
                        lucky.type = 'multiball'; lucky.color = '#ffd700';
                        createExplosion(lucky.x+BRICK_W/2, lucky.y+BRICK_H/2, '#fff');
                    }
                }

                if (b.type === 'multiball') {
                    const speeds = [3.0, 3.5, 3.0]; const angles = [-0.5, 0, 0.5]; 
                    let bounceAngle = Math.atan2(-ball.dy, -ball.dx); 
                    for (let j = 0; j < 3; j++) {
                        let pAngle = bounceAngle + angles[j];
                        projectiles.push({
                            x: b.x + BRICK_W/2, y: b.y + BRICK_H/2,
                            dx: Math.cos(pAngle) * speeds[j], dy: Math.sin(pAngle) * speeds[j], color: '#39ff14' 
                        });
                    }
                }

                if (b.type === 'speed') {
                    isSuperCharged = true; 
                    const currentMag = Math.sqrt(ball.dx*ball.dx + ball.dy*ball.dy);
                    if (currentMag > 0) {
                        ball.dx = (ball.dx / currentMag) * SUPER_SPEED; ball.dy = (ball.dy / currentMag) * SUPER_SPEED;
                    }
                } else {
                    if (isSuperCharged) {
                        isSuperCharged = false; 
                        const currentMag = Math.sqrt(ball.dx*ball.dx + ball.dy*ball.dy);
                        if (currentMag > 0) {
                            ball.dx = (ball.dx / currentMag) * normalSpeed; ball.dy = (ball.dy / currentMag) * normalSpeed;
                        }
                    }
                }

                if (Math.abs(distX) > Math.abs(distY)) ball.dx = -ball.dx; else ball.dy = -ball.dy; 
                break; 
            }
        }

        // 2. Wall / Paddle
        const distX = ball.x - CENTER_X;
        const distY = ball.y - CENTER_Y;
        const distanceFromCenter = Math.sqrt(distX * distX + distY * distY);

        if (!isHoldingBall && distanceFromCenter >= RADIUS - BALL_RADIUS) {
            let ballAngle = Math.atan2(distY, distX); 
            if (ballAngle < 0) ballAngle += Math.PI * 2;
            let angleDiff = ballAngle - paddleAngle;
            if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

            if (Math.abs(angleDiff) < PADDLE_WIDTH_RADIANS / 2) {
                playSound('paddle');
                let spinInfluence = angleDiff; 
                if (spinInfluence > 0.4) spinInfluence = 0.4;
                if (spinInfluence < -0.4) spinInfluence = -0.4;
                const deflectionFactor = 1.0; 
                const tiltedNormal = ballAngle + Math.PI + (spinInfluence * deflectionFactor);
                const nx = Math.cos(tiltedNormal); const ny = Math.sin(tiltedNormal);
                const dot = ball.dx * nx + ball.dy * ny;
                ball.dx = ball.dx - 2 * dot * nx; ball.dy = ball.dy - 2 * dot * ny;

                const targetSpeed = isSuperCharged ? SUPER_SPEED : normalSpeed;
                const velocityMagnitude = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                ball.dx = (ball.dx / velocityMagnitude) * targetSpeed;
                ball.dy = (ball.dy / velocityMagnitude) * targetSpeed;

                const overlap = distanceFromCenter - (RADIUS - BALL_RADIUS - 1);
                const angleToCenter = Math.atan2(CENTER_Y - ball.y, CENTER_X - ball.x);
                ball.x += Math.cos(angleToCenter) * overlap; ball.y += Math.sin(angleToCenter) * overlap;
            } else {
                if (!cheaterMode) lives--; 
                if (!cheaterMode) livesEl.innerText = `LIVES: ${lives}`;
                
                playSound('bomb');
                if (lives <= 0 && !cheaterMode) {
                    playSound('gameover'); gameState = 'GAMEOVER'; statusEl.innerText = "STATUS: GAME OVER";
                    statusEl.style.color = "#ff3333"; overlayEl.innerHTML = `GAME OVER<div class="sub-msg">PRESS SPACE TO RESTART</div>`;
                    overlayEl.style.display = 'block';
                } else { respawnBall(); }
            }
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. Arena
        ctx.beginPath(); ctx.arc(CENTER_X, CENTER_Y, RADIUS, 0, Math.PI * 2); ctx.lineWidth = 8; ctx.strokeStyle = '#00e5ff'; ctx.stroke();
        ctx.save(); ctx.beginPath(); ctx.arc(CENTER_X, CENTER_Y, BRICK_SPAWN_RADIUS + 20, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; ctx.setLineDash([10, 20]); ctx.lineWidth = 2; ctx.stroke(); ctx.restore(); 

        // 2. Entities
        for (let b of entities) {
            if (!b.active) continue;
            ctx.fillStyle = b.color;
            if (b.type === 'bomb') { if (Math.floor(Date.now() / 200) % 2 === 0) ctx.fillStyle = '#ff0000'; else ctx.fillStyle = '#600'; }
            if (b.type === 'multiball' || b.type === 'speed') { if (Math.floor(Date.now() / 100) % 2 === 0) ctx.fillStyle = b.color; else ctx.fillStyle = '#fff'; }
            ctx.fillRect(b.x, b.y, b.w, b.h); ctx.lineWidth = 3; ctx.strokeStyle = '#000'; ctx.strokeRect(b.x, b.y, b.w, b.h);
            if (b.type === 'bomb') {
                ctx.beginPath(); ctx.strokeStyle = '#000'; ctx.lineWidth = 4;
                ctx.moveTo(b.x + 5, b.y + 5); ctx.lineTo(b.x + b.w - 5, b.y + b.h - 5);
                ctx.moveTo(b.x + b.w - 5, b.y + 5); ctx.lineTo(b.x + 5, b.y + b.h - 5); ctx.stroke();
            }
            if (b.type === 'multiball') {
                ctx.fillStyle = '#000'; ctx.beginPath();
                ctx.arc(b.x + 10, b.y + 7, 2, 0, Math.PI*2); ctx.arc(b.x + 20, b.y + 7, 2, 0, Math.PI*2); ctx.arc(b.x + 15, b.y + 12, 2, 0, Math.PI*2); ctx.fill();
            }
            if (b.type === 'speed') {
                ctx.fillStyle = '#000'; ctx.beginPath(); ctx.moveTo(b.x + 10, b.y + 12); ctx.lineTo(b.x + 15, b.y + 3); ctx.lineTo(b.x + 20, b.y + 12); ctx.fill();
            }
        }

        drawParticles();

        // 3. Projectiles
        for (let p of projectiles) {
            ctx.beginPath(); ctx.arc(p.x, p.y, PROJECTILE_RADIUS, 0, Math.PI*2);
            ctx.fillStyle = p.color; ctx.shadowBlur = 10; ctx.shadowColor = p.color; ctx.fill(); ctx.shadowBlur = 0;
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
        }

        // 4. Catch Radius
        const now = Date.now();
        const timeSincePush = now - lastPushTime;
        const isReady = timeSincePush >= COOLDOWN_FIXED_MS;

        if (isReady && !isHoldingBall && gameState === 'PLAYING') {
            ctx.save(); ctx.beginPath(); const catchRadius = RADIUS - PUSH_MAX_DISTANCE; 
            ctx.arc(CENTER_X, CENTER_Y, catchRadius, paddleAngle - PADDLE_WIDTH_RADIANS / 2, paddleAngle + PADDLE_WIDTH_RADIANS / 2);
            const alpha = 0.5 + Math.sin(now / 200) * 0.3; ctx.strokeStyle = `rgba(0, 229, 255, ${alpha})`; 
            ctx.setLineDash([5, 5]); ctx.lineWidth = 3; ctx.stroke(); ctx.restore();
        }

        // 5. Paddle
        ctx.save(); ctx.beginPath();
        ctx.arc(CENTER_X, CENTER_Y, RADIUS, paddleAngle - PADDLE_WIDTH_RADIANS / 2, paddleAngle + PADDLE_WIDTH_RADIANS / 2);
        if (isHoldingBall) {
            ctx.strokeStyle = (downPressed || Math.abs(aimOffsetAngle) > 0.01) ? '#aa00ff' : '#00e5ff'; 
            ctx.shadowBlur = 15; ctx.shadowColor = ctx.strokeStyle;
        } else {
            ctx.strokeStyle = '#ffeb3b'; ctx.shadowBlur = 10; ctx.shadowColor = '#ffeb3b';
        }
        ctx.lineWidth = 14; ctx.lineCap = "round"; ctx.stroke(); ctx.restore();

        // 6. Aim Laser
        if (isHoldingBall) {
            ctx.save();
            const startX = ball.x; // Use Ball center
            const startY = ball.y;
            
            const shootAngle = paddleAngle + Math.PI + aimOffsetAngle;
            
            const rayDir = { x: Math.cos(shootAngle), y: Math.sin(shootAngle) };
            const rayOrigin = { x: startX, y: startY };
            let closestHit = null; let minT = Infinity;
            for (let b of entities) {
                if (!b.active) continue;
                let hit = getRayIntersection(rayOrigin, rayDir, b);
                if (hit && hit.t < minT) { minT = hit.t; closestHit = hit; }
            }
            ctx.beginPath(); ctx.moveTo(startX, startY);
            let endX, endY;
            if (closestHit) { endX = closestHit.x; endY = closestHit.y; } else { endX = startX + rayDir.x * 500; endY = startY + rayDir.y * 500; }
            ctx.lineTo(endX, endY); ctx.setLineDash([10, 10]); 
            ctx.strokeStyle = (downPressed || Math.abs(aimOffsetAngle) > 0.01) ? '#aa00ff' : '#00e5ff'; 
            ctx.lineWidth = 3; ctx.stroke();
            if (closestHit) {
                ctx.beginPath(); ctx.moveTo(closestHit.x, closestHit.y);
                const dot = rayDir.x * closestHit.normal.x + rayDir.y * closestHit.normal.y;
                const reflectX = rayDir.x - 2 * dot * closestHit.normal.x;
                const reflectY = rayDir.y - 2 * dot * closestHit.normal.y;
                ctx.lineTo(closestHit.x + reflectX * 150, closestHit.y + reflectY * 150);
                ctx.strokeStyle = 'rgba(255, 0, 255, 0.7)'; ctx.setLineDash([5, 5]); ctx.lineWidth = 2; ctx.stroke();
                ctx.beginPath(); ctx.arc(closestHit.x, closestHit.y, 4, 0, Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill();
            }
            ctx.restore();
        }

        // 7. Ball
        ctx.save(); ctx.beginPath(); ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI * 2);
        if (isSuperCharged) { ctx.fillStyle = '#00e5ff'; ctx.shadowBlur = 20; ctx.shadowColor = "#00e5ff"; } 
        else { ctx.fillStyle = '#fff'; ctx.shadowBlur = 0; }
        ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle = '#000'; ctx.stroke(); ctx.restore();

        // 8. PAUSE OVERLAY
        if (gameState === 'PAUSED') {
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff'; ctx.font = '80px Bangers'; ctx.textAlign = 'center'; ctx.fillText("PAUSED", CENTER_X, CENTER_Y);
            ctx.font = '30px Bangers'; ctx.fillText("Press Space to Resume", CENTER_X, CENTER_Y + 50);
        }
    }

    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    initGame();
    gameLoop();

</script>
</body>
</html>